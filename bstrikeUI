-- NO.FEAR Drawing UI Library v6.0 (RenderStepped architecture)
-- All positions recalculated every frame from WX/WY
-- Zero closures for positions, zero allD complexity

local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local DrawLib = {}

local function newDraw(type, props)
    local d = Drawing.new(type)
    for k,v in pairs(props) do d[k] = v end
    return d
end

function DrawLib:CreateWindow(cfg)
    local T = {
        BG      = Color3.fromRGB(28,28,28),
        SB      = Color3.fromRGB(22,22,22),
        Panel   = Color3.fromRGB(32,32,32),
        Line    = Color3.fromRGB(50,50,50),
        Pink    = Color3.fromRGB(255,100,160),
        Text    = Color3.fromRGB(220,220,220),
        Dim     = Color3.fromRGB(120,120,120),
        White   = Color3.fromRGB(255,255,255),
        Toggle  = Color3.fromRGB(60,60,60),
        TogOn   = Color3.fromRGB(255,100,160),
    }

    -- Window state
    local S = {
        x = 200, y = 150,   -- window position
        w = 680, h = 480,   -- window size
        sbw = 140,          -- sidebar width
        tbh = 32,           -- topbar height
        bth = 24,           -- bottom bar height
        visible = true,
        activeTab = 1,
        dragging = false,
        dragOX = 0, dragOY = 0,
        tabs = {},          -- {name, sections={}}
        elements = {},      -- flat list: {tabIdx, side, row, type, ...data}
        handlers = {},      -- {type, tabIdx, data, fn}
    }

    -- All drawings
    local draws = {}
    local function D(t,p) local d=newDraw(t,p); table.insert(draws,d); return d end

    -- Window chrome
    local dBG    = D("Square",{Filled=true,Color=T.BG,Transparency=0})
    local dSB    = D("Square",{Filled=true,Color=T.SB,Transparency=0})
    local dTB    = D("Square",{Filled=true,Color=Color3.fromRGB(20,20,20),Transparency=0})
    local dBB    = D("Square",{Filled=true,Color=Color3.fromRGB(20,20,20),Transparency=0})
    -- Logo as text (Drawing API has no Image type)
    local dLogo  = D("Text",{Text="NF",Color=Color3.fromRGB(180,0,255),Size=14,Font=Drawing.Fonts.GothamBold,Outline=false})
    local dTitle = D("Text",{Text=cfg.Title or "NoFear",Color=T.Pink,Size=15,Font=Drawing.Fonts.GothamBold,Outline=false})
    local dSub   = D("Text",{Text=(cfg.Game or "").." | ".. (cfg.Version or ""),Color=T.Dim,Size=11,Font=Drawing.Fonts.Gotham,Outline=false})
    local dBotTx = D("Text",{Text="discord.gg/G9QSXsB9wY | K to toggle",Color=T.Dim,Size=11,Font=Drawing.Fonts.Gotham,Outline=false})
    -- Sidebar/panel dividers
    local dSBDiv = D("Line",{Color=T.Line,Thickness=1})
    local dPDiv  = D("Line",{Color=T.Line,Thickness=1})

    -- Tab sidebar buttons (created per tab)
    local tabDraws = {} -- {bg, acc, txt}

    -- Stars
    local stars = {}
    task.spawn(function()
        while true do
            task.wait(0.5)
            if S.visible then
                local star = {
                    x = S.x + S.sbw + math.random(10, S.w-S.sbw-10),
                    y = S.y + S.tbh,
                    speed = math.random(40,80),
                    alpha = 1,
                    s1 = Drawing.new("Square"),
                    s2 = Drawing.new("Square"),
                }
                star.s1.Filled=true; star.s1.Color=T.White; star.s1.Transparency=0.7
                star.s1.Size=Vector2.new(6,2)
                star.s2.Filled=true; star.s2.Color=T.White; star.s2.Transparency=0.7
                star.s2.Size=Vector2.new(2,6)
                table.insert(stars, star)
            end
        end
    end)

    -- Layout helpers
    local PW  = 250  -- panel width
    local EH  = 22   -- element height
    local EPY = 8    -- element padding Y
    local EPX = 10   -- element padding X

    -- Add tab (accepts string or {Name=..., Icon=...} table)
    function S:AddTab(cfg)
        local name = type(cfg)=="table" and (cfg.Name or cfg.name or "Tab") or tostring(cfg)
        local idx = #S.tabs+1
        table.insert(S.tabs, {name=name, secs={}, lRows=0, rRows=0})
        local td = {
            bg  = D("Square",{Filled=true,Color=T.SB,Transparency=0}),
            acc = D("Square",{Filled=true,Color=T.Pink,Transparency=0}),
            txt = D("Text",{Text=name,Color=T.Dim,Size=13,Font=Drawing.Fonts.Gotham,Outline=false}),
        }
        td.acc.Size = Vector2.new(3,18)
        table.insert(tabDraws, td)
        -- click handler
        table.insert(S.handlers, {type="tab", tabIdx=idx})
        return {
            AddSection = function(_, secName, side)
                local isR = (side=="right")
                table.insert(S.tabs[idx].secs, {name=secName, side=isR and "right" or "left", rows=0, elems={}})
                local secIdx = #S.tabs[idx].secs
                local secHead = D("Text",{Text=secName,Color=T.Pink,Size=13,Font=Drawing.Fonts.GothamBold,Outline=false})
                local secLine = D("Line",{Color=T.Line,Thickness=1})
                table.insert(S.tabs[idx].secs[secIdx].elems, {type="secHead", d1=secHead, d2=secLine})
                if isR then S.tabs[idx].rRows = S.tabs[idx].rRows+1
                else S.tabs[idx].lRows = S.tabs[idx].lRows+1 end

                local function addElem(eType, eName, eData)
                    local row = isR and S.tabs[idx].rRows or S.tabs[idx].lRows
                    local elem = {type=eType, name=eName, side=isR and "right" or "left", row=row, tabIdx=idx}
                    for k,v in pairs(eData) do elem[k]=v end
                    table.insert(S.tabs[idx].secs[secIdx].elems, elem)
                    if isR then S.tabs[idx].rRows=S.tabs[idx].rRows+1
                    else S.tabs[idx].lRows=S.tabs[idx].lRows+1 end
                    return elem
                end

                return {
                    AddToggle = function(_, tcfg)
                        local state = tcfg.Default or false
                        local dLbl = D("Text",{Text=tcfg.Name,Color=T.Text,Size=13,Font=Drawing.Fonts.Gotham,Outline=false})
                        local dBox = D("Square",{Filled=true,Color=state and T.TogOn or T.Toggle,Transparency=0})
                        local dKnb = D("Square",{Filled=true,Color=T.White,Transparency=0})
                        dBox.Size = Vector2.new(34,18)
                        dKnb.Size = Vector2.new(12,12)
                        local elem = addElem("toggle", tcfg.Name, {state=state, d1=dLbl, d2=dBox, d3=dKnb, cb=tcfg.Callback})
                        table.insert(S.handlers, {type="toggle", elem=elem})
                        if tcfg.Callback and state then pcall(tcfg.Callback, state) end
                    end,
                    AddSlider = function(_, scfg)
                        local val = scfg.Default or scfg.Min or 0
                        local dLbl = D("Text",{Text=scfg.Name..": "..val,Color=T.Text,Size=13,Font=Drawing.Fonts.Gotham,Outline=false})
                        local dTrack = D("Square",{Filled=true,Color=T.Toggle,Transparency=0})
                        local dFill  = D("Square",{Filled=true,Color=T.Pink,Transparency=0})
                        dTrack.Size = Vector2.new(PW-EPX*2, 6)
                        dFill.Size  = Vector2.new(0,6)
                        local elem = addElem("slider", scfg.Name, {val=val, min=scfg.Min or 0, max=scfg.Max or 100, inc=scfg.Increment or 1, d1=dLbl, d2=dTrack, d3=dFill, cb=scfg.Callback, dragging=false})
                        table.insert(S.handlers, {type="slider", elem=elem})
                        if scfg.Callback then pcall(scfg.Callback, val) end
                    end,
                    AddLabel = function(_, lcfg)
                        local dLbl = D("Text",{Text=lcfg.Text or "",Color=lcfg.Color or T.Dim,Size=12,Font=Drawing.Fonts.Gotham,Outline=false})
                        addElem("label", lcfg.Text or "", {d1=dLbl})
                    end,
                    AddButton = function(_, bcfg)
                        local dLbl = D("Text",{Text=bcfg.Name,Color=T.Text,Size=13,Font=Drawing.Fonts.Gotham,Outline=false})
                        local dBox = D("Square",{Filled=true,Color=T.Toggle,Transparency=0})
                        dBox.Size = Vector2.new(PW-EPX*2, EH)
                        local elem = addElem("button", bcfg.Name, {d1=dLbl, d2=dBox, cb=bcfg.Callback})
                        table.insert(S.handlers, {type="button", elem=elem})
                    end,
                    AddDropdown = function(_, dcfg)
                        local val = (type(dcfg.Default)=="string" and dcfg.Default) or (dcfg.Options and tostring(dcfg.Options[1])) or ""
                        local dLbl = D("Text",{Text=dcfg.Name,Color=T.Dim,Size=12,Font=Drawing.Fonts.Gotham,Outline=false})
                        local dBox = D("Square",{Filled=true,Color=T.Toggle,Transparency=0})
                        local dVal = D("Text",{Text=val,Color=T.Text,Size=13,Font=Drawing.Fonts.Gotham,Outline=false})
                        dBox.Size = Vector2.new(PW-EPX*2, EH)
                        local elem = addElem("dropdown", dcfg.Name, {val=val, opts=dcfg.Options or {}, d1=dLbl, d2=dBox, d3=dVal, cb=dcfg.Callback})
                        table.insert(S.handlers, {type="dropdown", elem=elem})
                        if dcfg.Callback then pcall(dcfg.Callback, val) end
                    end,
                }
            end,
        }
    end

    -- Calculate element Y position
    local function getElemY(side, row)
        return S.y + S.tbh + EPY + row * (EH + EPY)
    end
    local function getElemX(side)
        if side == "right" then return S.x + S.sbw + PW + EPX
        else return S.x + S.sbw + EPX end
    end

    -- RenderStepped: reposition ALL drawings every frame
    local conn = RS.RenderStepped:Connect(function(dt)
        local mx = UIS:GetMouseLocation().X
        local my = UIS:GetMouseLocation().Y

        -- Drag
        if S.dragging then
            S.x = mx - S.dragOX
            S.y = my - S.dragOY
        end

        -- Show/hide all drawings based on visibility
        local vis = S.visible
        dBG.Visible=vis; dSB.Visible=vis; dTB.Visible=vis; dBB.Visible=vis
        dLogo.Visible=vis; dTitle.Visible=vis; dSub.Visible=vis; dBotTx.Visible=vis
        dSBDiv.Visible=vis; dPDiv.Visible=vis
        if not vis then
            for _,td in ipairs(tabDraws) do td.bg.Visible=false; td.acc.Visible=false; td.txt.Visible=false end
            for tabIdx,tab in ipairs(S.tabs) do
                for _,sec in ipairs(tab.secs) do
                    for _,el in ipairs(sec.elems) do
                        if el.d1 then el.d1.Visible=false end
                        if el.d2 then el.d2.Visible=false end
                        if el.d3 then el.d3.Visible=false end
                    end
                end
            end
            for _,st in ipairs(stars) do st.s1.Visible=false; st.s2.Visible=false end
            return
        end

        -- Update window chrome
        dBG.Position  = Vector2.new(S.x, S.y)
        dBG.Size      = Vector2.new(S.w, S.h)
        dSB.Position  = Vector2.new(S.x, S.y+S.tbh)
        dSB.Size      = Vector2.new(S.sbw, S.h-S.tbh-S.bth)
        dTB.Position  = Vector2.new(S.x, S.y)
        dTB.Size      = Vector2.new(S.w, S.tbh)
        dBB.Position  = Vector2.new(S.x, S.y+S.h-S.bth)
        dBB.Size      = Vector2.new(S.w, S.bth)
        dSBDiv.From   = Vector2.new(S.x+S.sbw, S.y+S.tbh)
        dSBDiv.To     = Vector2.new(S.x+S.sbw, S.y+S.h-S.bth)
        dPDiv.From    = Vector2.new(S.x+S.sbw+PW, S.y+S.tbh)
        dPDiv.To      = Vector2.new(S.x+S.sbw+PW, S.y+S.h-S.bth)
        dLogo.Position  = Vector2.new(S.x+8, S.y+8)
        dTitle.Position = Vector2.new(S.x+36, S.y+8)
        dSub.Position   = Vector2.new(S.x+S.w-200, S.y+10)
        dBotTx.Position = Vector2.new(S.x+S.w/2-100, S.y+S.h-S.bth+6)

        -- Update tab sidebar buttons
        for i, td in ipairs(tabDraws) do
            local ty = S.y+S.tbh+(i-1)*34
            local isActive = (i == S.activeTab)
            td.bg.Position  = Vector2.new(S.x, ty)
            td.bg.Size      = Vector2.new(S.sbw, 34)
            td.bg.Color     = isActive and Color3.fromRGB(38,28,38) or T.SB
            td.acc.Position = Vector2.new(S.x, ty+8)
            td.acc.Visible  = isActive
            td.txt.Position = Vector2.new(S.x+14, ty+10)
            td.txt.Color    = isActive and T.Pink or T.Dim
            td.bg.Visible   = true
            td.acc.Visible  = isActive
            td.txt.Visible  = true
        end

        -- Update elements for active tab only
        for tabIdx, tab in ipairs(S.tabs) do
            local isActiveTab = (tabIdx == S.activeTab)
            local lRow = 0
            local rRow = 0
            for _, sec in ipairs(tab.secs) do
                local isR = (sec.side == "right")
                for _, el in ipairs(sec.elems) do
                    local row = isR and rRow or lRow
                    local ex = getElemX(isR and "right" or "left")
                    local ey = getElemY(isR and "right" or "left", row)

                    if el.type == "secHead" then
                        el.d1.Position = Vector2.new(ex, ey)
                        el.d1.Visible  = isActiveTab
                        el.d2.From     = Vector2.new(ex, ey+16)
                        el.d2.To       = Vector2.new(ex+PW-EPX*2, ey+16)
                        el.d2.Visible  = isActiveTab
                        if isR then rRow=rRow+1 else lRow=lRow+1 end

                    elseif el.type == "toggle" then
                        local bx = ex+PW-EPX*2-34-EPX
                        el.d1.Position = Vector2.new(ex, ey+4)
                        el.d2.Position = Vector2.new(bx, ey+2)
                        el.d3.Position = Vector2.new(el.state and bx+18 or bx+2, ey+5)
                        el.d2.Color    = el.state and T.TogOn or T.Toggle
                        el.d1.Visible  = isActiveTab
                        el.d2.Visible  = isActiveTab
                        el.d3.Visible  = isActiveTab
                        -- store hit area
                        el._hx=bx; el._hy=ey+2; el._hw=34; el._hh=18
                        if isR then rRow=rRow+1 else lRow=lRow+1 end

                    elseif el.type == "slider" then
                        local tw = PW-EPX*2
                        local fill = math.floor(((el.val-el.min)/(el.max-el.min))*tw)
                        el.d1.Position = Vector2.new(ex, ey+2)
                        el.d1.Text     = el.name..": "..tostring(el.val)
                        el.d2.Position = Vector2.new(ex, ey+EH-6)
                        el.d2.Size     = Vector2.new(tw,6)
                        el.d3.Position = Vector2.new(ex, ey+EH-6)
                        el.d3.Size     = Vector2.new(fill,6)
                        el.d1.Visible  = isActiveTab
                        el.d2.Visible  = isActiveTab
                        el.d3.Visible  = isActiveTab
                        el._hx=ex; el._hy=ey+EH-8; el._hw=tw; el._hh=10
                        if isR then rRow=rRow+1 else lRow=lRow+1 end

                    elseif el.type == "label" then
                        el.d1.Position = Vector2.new(ex, ey+4)
                        el.d1.Visible  = isActiveTab
                        if isR then rRow=rRow+1 else lRow=lRow+1 end

                    elseif el.type == "button" then
                        el.d2.Position = Vector2.new(ex, ey)
                        el.d2.Size     = Vector2.new(PW-EPX*2, EH)
                        el.d1.Position = Vector2.new(ex+8, ey+4)
                        el.d1.Visible  = isActiveTab
                        el.d2.Visible  = isActiveTab
                        el._hx=ex; el._hy=ey; el._hw=PW-EPX*2; el._hh=EH
                        if isR then rRow=rRow+1 else lRow=lRow+1 end

                    elseif el.type == "dropdown" then
                        el.d1.Position = Vector2.new(ex, ey+2)
                        el.d2.Position = Vector2.new(ex, ey+EH-4)
                        el.d3.Position = Vector2.new(ex+8, ey+EH-2)
                        el.d1.Visible  = isActiveTab
                        el.d2.Visible  = isActiveTab
                        el.d3.Visible  = isActiveTab
                        el._hx=ex; el._hy=ey+EH-4; el._hw=PW-EPX*2; el._hh=EH
                        if isR then rRow=rRow+1 else lRow=lRow+1 end
                    end
                end
            end
        end

        -- Stars
        for i=#stars,1,-1 do
            local st=stars[i]
            st.y = st.y + st.speed*dt
            st.alpha = st.alpha - 0.4*dt
            local vis = st.alpha>0 and st.y<S.y+S.h-S.bth and S.visible
            st.s1.Visible=vis; st.s2.Visible=vis
            if vis then
                st.s1.Position=Vector2.new(st.x-3, st.y); st.s1.Transparency=1-st.alpha
                st.s2.Position=Vector2.new(st.x-1, st.y-2); st.s2.Transparency=1-st.alpha
            end
            if not vis then st.s1:Remove(); st.s2:Remove(); table.remove(stars,i) end
        end
    end)

    -- Input handling
    UIS.InputBegan:Connect(function(inp, gpe)
        if gpe then return end
        if inp.KeyCode == Enum.KeyCode.K then
            S.visible = not S.visible
            return
        end
        if inp.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        local mx = UIS:GetMouseLocation().X
        local my = UIS:GetMouseLocation().Y

        -- Drag topbar
        if mx>=S.x and mx<=S.x+S.w and my>=S.y and my<=S.y+S.tbh then
            S.dragging=true; S.dragOX=mx-S.x; S.dragOY=my-S.y
            return
        end

        if not S.visible then return end

        -- Tab clicks
        for i=1,#S.tabs do
            local ty=S.y+S.tbh+(i-1)*34
            if mx>=S.x and mx<=S.x+S.sbw and my>=ty and my<=ty+34 then
                S.activeTab=i; return
            end
        end

        -- Element clicks
        for _, h in ipairs(S.handlers) do
            if h.type=="toggle" and h.elem.tabIdx==S.activeTab then
                local e=h.elem
                if e._hx and mx>=e._hx and mx<=e._hx+e._hw and my>=e._hy and my<=e._hy+e._hh then
                    e.state=not e.state
                    if e.cb then pcall(e.cb, e.state) end
                    return
                end
            elseif h.type=="button" and h.elem.tabIdx==S.activeTab then
                local e=h.elem
                if e._hx and mx>=e._hx and mx<=e._hx+e._hw and my>=e._hy and my<=e._hy+e._hh then
                    if e.cb then pcall(e.cb) end
                    return
                end
            elseif h.type=="dropdown" and h.elem.tabIdx==S.activeTab then
                local e=h.elem
                if e._hx and mx>=e._hx and mx<=e._hx+e._hw and my>=e._hy and my<=e._hy+e._hh then
                    local idx=1
                    for i,o in ipairs(e.opts) do if o==e.val then idx=i break end end
                    idx=(idx%#e.opts)+1
                    e.val=e.opts[idx]
                    e.d3.Text=tostring(e.val)
                    if e.cb then pcall(e.cb, e.val) end
                    return
                end
            elseif h.type=="slider" and h.elem.tabIdx==S.activeTab then
                local e=h.elem
                if e._hx and mx>=e._hx and mx<=e._hx+e._hw and my>=e._hy and my<=e._hy+e._hh then
                    e.dragging=true
                end
            end
        end
    end)

    UIS.InputChanged:Connect(function(inp)
        if inp.UserInputType ~= Enum.UserInputType.MouseMovement then return end
        local mx = UIS:GetMouseLocation().X
        for _, h in ipairs(S.handlers) do
            if h.type=="slider" and h.elem.dragging and h.elem.tabIdx==S.activeTab then
                local e=h.elem
                local tw=PW-EPX*2
                local pct=math.clamp((mx-e._hx)/tw,0,1)
                local raw=e.min+pct*(e.max-e.min)
                local stepped=math.floor(raw/e.inc+0.5)*e.inc
                e.val=math.clamp(stepped,e.min,e.max)
                if e.cb then pcall(e.cb,e.val) end
            end
        end
    end)

    UIS.InputEnded:Connect(function(inp)
        if inp.UserInputType==Enum.UserInputType.MouseButton1 then
            S.dragging=false
            for _,h in ipairs(S.handlers) do
                if h.type=="slider" then h.elem.dragging=false end
            end
        end
    end)

    -- Finalize â€” no-op for compatibility
    function S:Finalize() end

    function S:Destroy()
        conn:Disconnect()
        for _,d in ipairs(draws) do pcall(function() d:Remove() end) end
        for _,st in ipairs(stars) do pcall(function() st.s1:Remove(); st.s2:Remove() end) end
    end

    return S
end

return DrawLib
